// [Blend2D]
module bindbc.blend2d.bind.blapi;

import core.stdc.stddef;
import core.stdc.string;
import core.stdc.stdint;
import core.stdc.stdarg;

import bindbc.blend2d.bind.blpath;
import bindbc.blend2d.bind.blgeometry;
import bindbc.blend2d.bind.blarray;
import bindbc.blend2d.bind.blcontext;
import bindbc.blend2d.bind.blimage;
import bindbc.blend2d.bind.blmatrix;
import bindbc.blend2d.bind.blfont;
import bindbc.blend2d.bind.blfontdefs;
import bindbc.blend2d.bind.blfilesystem;
import bindbc.blend2d.bind.blglyphbuffer;
import bindbc.blend2d.bind.blformat;
import bindbc.blend2d.bind.blgradient;
import bindbc.blend2d.bind.blpattern;
import bindbc.blend2d.bind.blpixelconverter;
import bindbc.blend2d.bind.blrandom;
import bindbc.blend2d.bind.blregion;
import bindbc.blend2d.bind.blstring;

extern (System):

// 2D Vector Graphics Powered by a JIT Compiler.
//
// [License]
// Zlib - See LICENSE.md file in the package.

// This header can only be included by either <blend2d.h> or by Blend2D headers
// during the build. Prevent users including <blend2d/> headers by accident and
// prevent not including "blend2d/blapi-build_p.h" during the build.
// Include either <blend2d.h> or <blend2d-impl.h> to use Blend2D library.

// ----------------------------------------------------------------------------
// [Documentation]
// ----------------------------------------------------------------------------

//! \mainpage API Reference
//!
//! Blend2D C/C++ API reference documentation generated by Doxygen.
//!
//! \section main_introduction Introduction
//!
//! Blend2D API consists of enumerations, functions, structs, and C++ classes.
//! Common concepts like enumerations and POD structs are shared between C and
//! C++. Some structs contain extra functionality like `BLSomething::reset()`
//! that is only available to C++ users, however, such functionality is only
//! provided for convenience and doesn't affect how Blend2D can be used from C.
//!
//! Blend2D C++ API is in fact build on top of the C API and all C++ functions
//! are inlines that call C API without any overhead. It would require double
//! effort to document both C and C++ APIs separately so we have decided to only
//! document C++ API and to only list \ref blend2d_api_c_functions "C API" for
//! users that need it. The C API should be straightforward and matches very
//! well the C++ part.
//!
//! \section main_important Important
//!
//! Doxygen sorts struct members in anonymous structs and unions and we haven't
//! figured out how to turn this off. This means that the order of members in
//! "Public Attributes" doesn't have to reflect the original struct packing.
//! So please always double-check struct members in case you plan to use
//! braces-based initialization of simple structs.
//!
//! \section main_groups Groups
//!
//! The documentation is split into the following groups:
//!
//! $$DOCS_GROUP_OVERVIEW$$
//!
//! \section main_other Other Pages
//!
//!   - <a href="../doc/getting-started.html">Getting Started</a> - Covers basic
//!     setup and few sample applications
//!   - <a href="annotated.html">Class List</a> - Provides a list of classes
//!     sorted alphabetically

//! \defgroup blend2d_api_globals Global API
//! \brief Global functions, constants,  and classes used universally across
//! the library.

//! \defgroup blend2d_api_geometry Geometry API
//! \brief Geometries, paths, and transformations.
//!
//! Blend2D offers various geometry structures and objects that can be used with
//! either `BLPath` for path building or `BLContext` for rendering.

//! \defgroup blend2d_api_imaging Imaging API
//! \brief Images and image codecs.

//! \defgroup blend2d_api_styling Styling API
//! \brief Colors, gradients, and patterns.

//! \defgroup blend2d_api_text Text API
//! \brief Fonts & Text support.

//! \defgroup blend2d_api_rendering Rendering API
//! \brief 2D rendering context, helper structures, and constants.

//! \defgroup blend2d_api_runtime Runtime API
//! \brief Interaction with Blend2D runtime.

//! \defgroup blend2d_api_filesystem Filesystem API
//! \brief Filesystem utilities.

//! \defgroup blend2d_api_impl Impl API
//! \brief API required for extending Blend2D functionality.
//!
//! Everything that is part of this group requires `<blend2d-impl.h>` to be
//! included before the use as this API is only for users that extend Blend2D.

//! \defgroup blend2d_api_macros Macros
//! \brief Preprocessor macros and compile-time constants.

//! \defgroup blend2d_api_c_functions C API
//! \brief Global C API functions exported as `extern "C"` (C API).
//!
//! We do not document these functions as they are called from C++ wrappers,
//! which are documented and should be used as a reference. The most important
//! thing in using C API is to understand how lifetime of objects is managed.
//!
//! Each type that requires initialization provides `Init` and `Reset` functions.
//! These functions are called by C++ constructors and destructors on C++ side
//! and must be used the same way by C users. Although these functions return
//! `BLResult` it's guaranteed the result is always `BL_SUCCESS` - the return
//! value is only provided for consistency and possible tail calling.
//!
//! The following example should illustrate how `Init` and `Reset` works:
//!
//! ```
//! BLImageCore img;
//! blImageInit(&img);
//! blImageCreate(&img, 128, 128, BL_FORMAT_PRGB32);
//! blImageReset(&img);
//! ```
//!
//! Some init functions may provide shortcuts for the most used scenarios that
//! merge initialization and resource allocation into a single function.
//!
//! ```
//! BLImageCore img;
//! blImageInitAs(&img, 128, 128, BL_FORMAT_PRGB32);
//! blImageReset(&img);
//! ```
//!
//! It's worth knowing that default initialization in Blend2D costs nothing
//! and no resources are allocated, thus initialization never fails and in
//! theory default initialized objects don't have to be reset as they don't
//! hold any data (however never do that in practice). Resetting always resets
//! the object into its default initialized form, so you can reuse such object
//! afterwards (after reset it's still properly initialized) or consider it
//! destroyed.
//!
//! The following example should explain how init/reset works:
//!
//! \code
//! BLImageCore img;
//!
//! // Now image is default constructed/initialized. if you did just this and
//! // abandon it then no resources will be leaked as default construction is
//! // not allocating any resources nor increasing any reference counters.
//! blImageInit(&img);
//!
//! // Now image will have to dynamically allocate some memory to store pixel
//! // data. If this succeeds the image will have to be reset to destroy the
//! // data it holds.
//! BLResult result = blImageCreate(&img, 128, 128, BL_FORMAT_PRGB32);
//! if (result != BL_SUCCESS) {
//!   // If function fails it should behave like it was never called, so `img`
//!   // would still be default initialized in this case. this means that you
//!   // don't have to reset it explicitly although the C++ API would do it in
//!   // image destructor.
//!   return result;
//! }
//!
//! // Resetting image would destroy its data and make it default constructed.
//! blImageReset(&img);
//!
//! // You can still use the image after it has been reset as the data it holds
//! // is still valid, but the image is of course empty.
//! printf("%d", blImageEquals(&img, &img));
//! \endcode

//! \cond INTERNAL

//! \defgroup blend2d_internal Internal
//!
//! \brief Internal API.

//! \defgroup blend2d_internal_codecs Codecs
//!
//! \brief Codecs implementation.

//! \defgroup blend2d_internal_raster Raster
//!
//! \brief Raster rendering context.

//! \defgroup blend2d_internal_pipegen PipeGen
//!
//! \brief Pipeline generator.

//! \defgroup blend2d_internal_opentype OpenType
//!
//! \brief OpenType implementation.

//! \endcond

// ============================================================================
// [Version]
// ============================================================================

//! \addtogroup blend2d_api_macros
//! \{

//! \name Version Information
//! \{

//! Makes a version number representing a `MAJOR.MINOR.PATCH` combination.
extern (D) auto BL_MAKE_VERSION(T0, T1, T2)(auto ref T0 MAJOR, auto ref T1 MINOR, auto ref T2 PATCH) {
    return (MAJOR << 16) | (MINOR << 8) | PATCH;
}

//! Blend2D library version.
enum BL_VERSION = BL_MAKE_VERSION(0, 0, 1);

//! \}

//! \}

// ============================================================================
// [Public Macros]
// ============================================================================

//! \addtogroup blend2d_api_macros
//! \{

//! \name Target Information
//! \{

//! \def BL_BYTE_ORDER
//!
//! A compile-time constant (macro) that defines byte-order of the target. It
//! can be either `1234` for little-endian targets or `4321` for big-endian
//! targets. Blend2D uses this macro internally, but it's also available to
//! end users as sometimes it could be important for deciding between pixel
//! formats or other important details.

enum BL_BYTE_ORDER = 1234;

//! \}

//! \name Utilities
//! \{

//! Creates a 32-bit tag (uint32_t) from the given `A`, `B`, `C`, and `D` values.
extern (D) auto BL_MAKE_TAG(T0, T1, T2, T3)(auto ref T0 A, auto ref T1 B, auto ref T2 C, auto ref T3 D) {
    return cast(BLTag)(cast(BLTag) A << 24) | (cast(BLTag) B << 16) | (cast(BLTag) C << 8) | (cast(BLTag) D);
}

//! \}

//! \}

// ============================================================================
// [Public Types]
// ============================================================================

//! \ingroup blend2d_api_globals
//!
//! Result code used by most Blend2D functions (32-bit unsigned integer).
//!
//! The `BLResultCode` enumeration contains Blend2D result codes that contain
//! Blend2D specific set of errors and an extended set of errors that can come
//! from WIN32 or POSIX APIs. Since the success result code is zero it's
//! recommended to use the following check to determine whether a call failed
//! or not:
//!
//! ```
//! BLResult result = doSomething();
//! if (result != BL_SUCCESS) {
//!   // `doSomething()` failed...
//! }
//! ```
alias BLResult = uint;

//! \ingroup blend2d_api_globals
//!
//! A type used to store a pack of bits (typedef to `uintptr_t`).
//!
//! BitWord should be equal in size to a machine word.
alias BLBitWord = ulong;

//! \ingroup blend2d_api_globals
//!
//! Tag is a 32-bit integer consisting of 4 characters in the following format:
//!
//! ```
//! tag = ((a << 24) | (b << 16) | (c << 8) | d)
//! ```
//!
//! Tags are used extensively by OpenType fonts and other binary formats like
//! PNG. In most cases TAGs should only contain ASCII letters, digits, and spaces.
//!
//! Blend2D uses `BLTag` in public and internal APIs to distinguish between a
//! regular `uint32_t` and tag.
alias BLTag = uint;

//! \ingroup blend2d_api_globals
//!
//! A function callback that is called when an Impl is destroyed. It's often used
//! to notify that a data passed to a certain Impl is no longer in use.
alias BLDestroyImplFunc = void function(void* impl, void* destroyData);

//! \ingroup blend2d_api_geometry
//!
//! Optional callback that can be used to consume a path data.
alias BLPathSinkFunc = uint function(BLPathCore* path, const(void)* info, void* closure);

//! \ingroup blend2d_api_text
//!
//! Glyph identifier is an index to a glyph stored in a font.
//!
//! GlyphId is always an unsigned 16-bit integer as used by TrueType and OpenType
//! fonts. There are some libraries that use 32-bit integers for Glyph indexes,
//! but values above 65535 are never used in practice as font's generally do
//! not have the ability to index more than 65535 glyphs (excluding null glyph).
alias BLGlyphId = ushort;

// ============================================================================
// [Constants]
// ============================================================================

//! \ingroup blend2d_api_globals
//!
//! Blend2D result code.
enum BLResultCode {
    //! Successful result code.
    BL_SUCCESS = 0,

    BL_ERROR_START_INDEX = 0x00010000u,

    BL_ERROR_OUT_OF_MEMORY = 0x00010000u, //!< Out of memory                 [ENOMEM].
    BL_ERROR_INVALID_VALUE = 65537, //!< Invalid value/argument        [EINVAL].
    BL_ERROR_INVALID_STATE = 65538, //!< Invalid state                 [EFAULT].
    BL_ERROR_INVALID_HANDLE = 65539, //!< Invalid handle or file.       [EBADF].
    BL_ERROR_VALUE_TOO_LARGE = 65540, //!< Value too large               [EOVERFLOW].
    BL_ERROR_NOT_INITIALIZED = 65541, //!< Not initialized (some instance is built-in none when it shouldn't be).
    BL_ERROR_NOT_IMPLEMENTED = 65542, //!< Not implemented               [ENOSYS].
    BL_ERROR_NOT_PERMITTED = 65543, //!< Operation not permitted       [EPERM].

    BL_ERROR_IO = 65544, //!< IO error                      [EIO].
    BL_ERROR_BUSY = 65545, //!< Device or resource busy       [EBUSY].
    BL_ERROR_INTERRUPTED = 65546, //!< Operation interrupted         [EINTR].
    BL_ERROR_TRY_AGAIN = 65547, //!< Try again                     [EAGAIN].
    BL_ERROR_TIMED_OUT = 65548, //!< Timed out                     [ETIMEDOUT].
    BL_ERROR_BROKEN_PIPE = 65549, //!< Broken pipe                   [EPIPE].
    BL_ERROR_INVALID_SEEK = 65550, //!< File is not seekable          [ESPIPE].
    BL_ERROR_SYMLINK_LOOP = 65551, //!< Too many levels of symlinks   [ELOOP].
    BL_ERROR_FILE_TOO_LARGE = 65552, //!< File is too large             [EFBIG].
    BL_ERROR_ALREADY_EXISTS = 65553, //!< File/directory already exists [EEXIST].
    BL_ERROR_ACCESS_DENIED = 65554, //!< Access denied                 [EACCES].
    BL_ERROR_MEDIA_CHANGED = 65555, //!< Media changed                 [Windows::ERROR_MEDIA_CHANGED].
    BL_ERROR_READ_ONLY_FS = 65556, //!< The file/FS is read-only      [EROFS].
    BL_ERROR_NO_DEVICE = 65557, //!< Device doesn't exist          [ENXIO].
    BL_ERROR_NO_ENTRY = 65558, //!< Not found, no entry (fs)      [ENOENT].
    BL_ERROR_NO_MEDIA = 65559, //!< No media in drive/device      [ENOMEDIUM].
    BL_ERROR_NO_MORE_DATA = 65560, //!< No more data / end of file    [ENODATA].
    BL_ERROR_NO_MORE_FILES = 65561, //!< No more files                 [ENMFILE].
    BL_ERROR_NO_SPACE_LEFT = 65562, //!< No space left on device       [ENOSPC].
    BL_ERROR_NOT_EMPTY = 65563, //!< Directory is not empty        [ENOTEMPTY].
    BL_ERROR_NOT_FILE = 65564, //!< Not a file                    [EISDIR].
    BL_ERROR_NOT_DIRECTORY = 65565, //!< Not a directory               [ENOTDIR].
    BL_ERROR_NOT_SAME_DEVICE = 65566, //!< Not same device               [EXDEV].
    BL_ERROR_NOT_BLOCK_DEVICE = 65567, //!< Not a block device            [ENOTBLK].

    BL_ERROR_INVALID_FILE_NAME = 65568, //!< File/path name is invalid     [n/a].
    BL_ERROR_FILE_NAME_TOO_LONG = 65569, //!< File/path name is too long    [ENAMETOOLONG].

    BL_ERROR_TOO_MANY_OPEN_FILES = 65570, //!< Too many open files           [EMFILE].
    BL_ERROR_TOO_MANY_OPEN_FILES_BY_OS = 65571, //!< Too many open files by OS     [ENFILE].
    BL_ERROR_TOO_MANY_LINKS = 65572, //!< Too many symbolic links on FS [EMLINK].
    BL_ERROR_TOO_MANY_THREADS = 65573, //!< Too many threads              [EAGAIN].

    BL_ERROR_FILE_EMPTY = 65574, //!< File is empty (not specific to any OS error).
    BL_ERROR_OPEN_FAILED = 65575, //!< File open failed              [Windows::ERROR_OPEN_FAILED].
    BL_ERROR_NOT_ROOT_DEVICE = 65576, //!< Not a root device/directory   [Windows::ERROR_DIR_NOT_ROOT].

    BL_ERROR_UNKNOWN_SYSTEM_ERROR = 65577, //!< Unknown system error that failed to translate to Blend2D result code.

    BL_ERROR_INVALID_ALIGNMENT = 65578, //!< Invalid data alignment.
    BL_ERROR_INVALID_SIGNATURE = 65579, //!< Invalid data signature or header.
    BL_ERROR_INVALID_DATA = 65580, //!< Invalid or corrupted data.
    BL_ERROR_INVALID_STRING = 65581, //!< Invalid string (invalid data of either UTF8, UTF16, or UTF32).
    BL_ERROR_DATA_TRUNCATED = 65582, //!< Truncated data (more data required than memory/stream provides).
    BL_ERROR_DATA_TOO_LARGE = 65583, //!< Input data too large to be processed.
    BL_ERROR_DECOMPRESSION_FAILED = 65584, //!< Decompression failed due to invalid data (RLE, Huffman, etc).

    BL_ERROR_INVALID_GEOMETRY = 65585, //!< Invalid geometry (invalid path data or shape).
    BL_ERROR_NO_MATCHING_VERTEX = 65586, //!< Returned when there is no matching vertex in path data.

    BL_ERROR_NO_MATCHING_COOKIE = 65587, //!< No matching cookie (BLContext).
    BL_ERROR_NO_STATES_TO_RESTORE = 65588, //!< No states to restore (BLContext).

    BL_ERROR_IMAGE_TOO_LARGE = 65589, //!< The size of the image is too large.
    BL_ERROR_IMAGE_NO_MATCHING_CODEC = 65590, //!< Image codec for a required format doesn't exist.
    BL_ERROR_IMAGE_UNKNOWN_FILE_FORMAT = 65591, //!< Unknown or invalid file format that cannot be read.
    BL_ERROR_IMAGE_DECODER_NOT_PROVIDED = 65592, //!< Image codec doesn't support reading the file format.
    BL_ERROR_IMAGE_ENCODER_NOT_PROVIDED = 65593, //!< Image codec doesn't support writing the file format.

    BL_ERROR_PNG_MULTIPLE_IHDR = 65594, //!< Multiple IHDR chunks are not allowed (PNG).
    BL_ERROR_PNG_INVALID_IDAT = 65595, //!< Invalid IDAT chunk (PNG).
    BL_ERROR_PNG_INVALID_IEND = 65596, //!< Invalid IEND chunk (PNG).
    BL_ERROR_PNG_INVALID_PLTE = 65597, //!< Invalid PLTE chunk (PNG).
    BL_ERROR_PNG_INVALID_TRNS = 65598, //!< Invalid tRNS chunk (PNG).
    BL_ERROR_PNG_INVALID_FILTER = 65599, //!< Invalid filter type (PNG).

    BL_ERROR_JPEG_UNSUPPORTED_FEATURE = 65600, //!< Unsupported feature (JPEG).
    BL_ERROR_JPEG_INVALID_SOS = 65601, //!< Invalid SOS marker or header (JPEG).
    BL_ERROR_JPEG_INVALID_SOF = 65602, //!< Invalid SOF marker (JPEG).
    BL_ERROR_JPEG_MULTIPLE_SOF = 65603, //!< Multiple SOF markers (JPEG).
    BL_ERROR_JPEG_UNSUPPORTED_SOF = 65604, //!< Unsupported SOF marker (JPEG).

    BL_ERROR_FONT_NO_CHARACTER_MAPPING = 65605, //!< Font has no character to glyph mapping data.
    BL_ERROR_FONT_MISSING_IMPORTANT_TABLE = 65606, //!< Font has missing an important table.
    BL_ERROR_FONT_FEATURE_NOT_AVAILABLE = 65607, //!< Font feature is not available.
    BL_ERROR_FONT_CFF_INVALID_DATA = 65608, //!< Font has an invalid CFF data.
    BL_ERROR_FONT_PROGRAM_TERMINATED = 65609, //!< Font program terminated because the execution reached the limit.

    BL_ERROR_INVALID_GLYPH = 65610 //!< Invalid glyph identifier.
}

//! \ingroup blend2d_api_globals
//!
//! Byte order.
enum BLByteOrder {
    //! Little endian byte-order.
    BL_BYTE_ORDER_LE = 0,
    //! Big endian byte-order.
    BL_BYTE_ORDER_BE = 1,

    //! Native (host) byte-order.
    BL_BYTE_ORDER_NATIVE = BL_BYTE_ORDER == 1234 ? BL_BYTE_ORDER_LE : BL_BYTE_ORDER_BE,
    //! Swapped byte-order (BE if host is LE and vice versa).
    BL_BYTE_ORDER_SWAPPED = BL_BYTE_ORDER == 1234 ? BL_BYTE_ORDER_BE : BL_BYTE_ORDER_LE
}

//! \ingroup blend2d_api_globals
//!
//! Data access flags.
enum BLDataAccessFlags {
    //! Read access.
    BL_DATA_ACCESS_READ = 0x01u,
    //! Write access.
    BL_DATA_ACCESS_WRITE = 0x02u,
    //! Read and write access.
    BL_DATA_ACCESS_RW = 0x03u
}

//! \ingroup blend2d_api_globals
//!
//! Data source type.
enum BLDataSourceType {
    //! No data source.
    BL_DATA_SOURCE_TYPE_NONE = 0,
    //! Memory data source.
    BL_DATA_SOURCE_TYPE_MEMORY = 1,
    //! File data source.
    BL_DATA_SOURCE_TYPE_FILE = 2,
    //! Custom data source.
    BL_DATA_SOURCE_TYPE_CUSTOM = 3,

    //! Count of data source types.
    BL_DATA_SOURCE_TYPE_COUNT = 4
}

//! \ingroup blend2d_api_globals
//!
//! Modification operation applied to Blend2D containers.
enum BLModifyOp {
    //! Assign operation and reserve only space to fit the input.
    BL_MODIFY_OP_ASSIGN_FIT = 0,
    //! Assign operation and reserve more capacity for growing.
    BL_MODIFY_OP_ASSIGN_GROW = 1,
    //! Append operation and reserve only space to fit the input.
    BL_MODIFY_OP_APPEND_FIT = 2,
    //! Append operation and reserve more capacity for growing.
    BL_MODIFY_OP_APPEND_GROW = 3,

    //! Count of data operations.
    BL_MODIFY_OP_COUNT = 4
}

//! \ingroup blend2d_api_globals
//!
//! Boolean operator.
enum BLBooleanOp {
    //! Result = B.
    BL_BOOLEAN_OP_COPY = 0,
    //! Result = A & B.
    BL_BOOLEAN_OP_AND = 1,
    //! Result = A | B.
    BL_BOOLEAN_OP_OR = 2,
    //! Result = A ^ B.
    BL_BOOLEAN_OP_XOR = 3,
    //! Result = A - B.
    BL_BOOLEAN_OP_SUB = 4,

    BL_BOOLEAN_OP_COUNT = 5
}

//! \ingroup blend2d_api_styling
//!
//! Extend mode.
enum BLExtendMode {
    //! Pad extend [default].
    BL_EXTEND_MODE_PAD = 0,
    //! Repeat extend.
    BL_EXTEND_MODE_REPEAT = 1,
    //! Reflect extend.
    BL_EXTEND_MODE_REFLECT = 2,

    //! Alias to `BL_EXTEND_MODE_PAD`.
    BL_EXTEND_MODE_PAD_X_PAD_Y = 0,
    //! Alias to `BL_EXTEND_MODE_REPEAT`.
    BL_EXTEND_MODE_REPEAT_X_REPEAT_Y = 1,
    //! Alias to `BL_EXTEND_MODE_REFLECT`.
    BL_EXTEND_MODE_REFLECT_X_REFLECT_Y = 2,
    //! Pad X and repeat Y.
    BL_EXTEND_MODE_PAD_X_REPEAT_Y = 3,
    //! Pad X and reflect Y.
    BL_EXTEND_MODE_PAD_X_REFLECT_Y = 4,
    //! Repeat X and pad Y.
    BL_EXTEND_MODE_REPEAT_X_PAD_Y = 5,
    //! Repeat X and reflect Y.
    BL_EXTEND_MODE_REPEAT_X_REFLECT_Y = 6,
    //! Reflect X and pad Y.
    BL_EXTEND_MODE_REFLECT_X_PAD_Y = 7,
    //! Reflect X and repeat Y.
    BL_EXTEND_MODE_REFLECT_X_REPEAT_Y = 8,

    //! Count of simple extend modes (that use the same value for X and Y).
    BL_EXTEND_MODE_SIMPLE_COUNT = 3,
    //! Count of complex extend modes (that can use independent values for X and Y).
    BL_EXTEND_MODE_COMPLEX_COUNT = 9
}

//! \ingroup blend2d_api_styling
//!
//! Style type.
enum BLStyleType {
    //! No style, nothing will be paint.
    BL_STYLE_TYPE_NONE = 0,
    //! Solid color style.
    BL_STYLE_TYPE_SOLID = 1,
    //! Pattern style.
    BL_STYLE_TYPE_PATTERN = 2,
    //! Gradient style.
    BL_STYLE_TYPE_GRADIENT = 3,

    //! Count of style types.
    BL_STYLE_TYPE_COUNT = 4
}

//! \ingroup blend2d_api_text
//!
//! Text encoding.
enum BLTextEncoding {
    //! UTF-8 encoding.
    BL_TEXT_ENCODING_UTF8 = 0,
    //! UTF-16 encoding (native endian).
    BL_TEXT_ENCODING_UTF16 = 1,
    //! UTF-32 encoding (native endian).
    BL_TEXT_ENCODING_UTF32 = 2,
    //! LATIN1 encoding (one byte per character).
    BL_TEXT_ENCODING_LATIN1 = 3,

    //! Platform native `wchar_t` (or Windows `WCHAR`) encoding, alias to
    //! either UTF-32, UTF-16, or UTF-8 depending on `sizeof(wchar_t)`.
    BL_TEXT_ENCODING_WCHAR
        = wchar_t.sizeof == 4 ? BL_TEXT_ENCODING_UTF32 :
          wchar_t.sizeof == 2 ? BL_TEXT_ENCODING_UTF16 : BL_TEXT_ENCODING_UTF8,

    //! Count of text supported text encodings.
    BL_TEXT_ENCODING_COUNT = 4
}

// ============================================================================
// [Public API - TraceError]
// ============================================================================

//! \addtogroup blend2d_api_globals
//! \{
//! \name Debugging Functionality
//! \{

//! Returns the `result` passed.
//!
//! Provided for debugging purposes. Putting a breakpoint inside `blTraceError()`
//! can help with tracing an origin of errors reported / returned by Blend2D as
//! each error goes through this function.
//!
//! It's a zero-cost solution that doesn't affect release builds in any way.
BLResult blTraceError(BLResult result);

//! \}
//! \}

// ============================================================================
// [BLRange]
// ============================================================================

//! \addtogroup blend2d_api_globals
//! \{

//! Provides start and end indexes. It's used to specify a range of an operation
//! related to indexed containers like `BLArray`, `BLPath`, `BLGradient`, etc...
struct BLRange {
    size_t start;
    size_t end;
}

//! \}

// ============================================================================
// [BLCreateForeignInfo]
// ============================================================================

//! \addtogroup blend2d_api_globals
//! \{

//! Structure passed to a constructor (initializer) that provides foreign data
//! that should be used to allocate its Impl (and data if it's a container).
struct BLCreateForeignInfo {
    void* data;
    size_t size;
    BLDestroyImplFunc destroyFunc;
    void* destroyData;
}

//! \}

// ============================================================================
// [BLArrayView]
// ============================================================================

//! \addtogroup blend2d_api_globals
//! \{

struct BLArrayView {
    const(void)* data;
    size_t size;
}

struct BLStringView {
    const(char)* data;
    size_t size;
}

struct BLRegionView {
    const(BLBoxI)* data;
    size_t size;
}

alias BLDataView = BLArrayView;

//! \}

// ============================================================================
// [C Interface - Core]
// ============================================================================

//! \addtogroup blend2d_api_c_functions
//! \{

//! \name BLArray
//!
//! Array functionality is provided by \ref BLArrayCore in C-API and wrapped by
//! \ref BLArray template in C++ API.
//!
//! C API users must call either generic functions with `Item` suffix or correct
//! specialized functions in case of typed arrays. For example if you create a
//! `BLArray<uint32_t>` in C then you can only modify it through functions that
//! have either `U32` or `Item` suffix. Arrays of signed types are treated as
//! arrays of unsigned types at API level as there is no difference between them
//! from implementation perspective.
//!
//! \{
BLResult blArrayInit(BLArrayCore* self, uint arrayTypeId);
BLResult blArrayReset(BLArrayCore* self);
BLResult blArrayCreateFromData(BLArrayCore* self, void* data, size_t size, size_t capacity, uint dataAccessFlags, BLDestroyImplFunc destroyFunc, void* destroyData);
size_t blArrayGetSize(const(BLArrayCore)* self);
size_t blArrayGetCapacity(const(BLArrayCore)* self);
const(void)* blArrayGetData(const(BLArrayCore)* self);
BLResult blArrayClear(BLArrayCore* self);
BLResult blArrayShrink(BLArrayCore* self);
BLResult blArrayReserve(BLArrayCore* self, size_t n);
BLResult blArrayResize(BLArrayCore* self, size_t n, const(void)* fill);
BLResult blArrayMakeMutable(BLArrayCore* self, void** dataOut);
BLResult blArrayModifyOp(BLArrayCore* self, uint op, size_t n, void** dataOut);
BLResult blArrayInsertOp(BLArrayCore* self, size_t index, size_t n, void** dataOut);
BLResult blArrayAssignMove(BLArrayCore* self, BLArrayCore* other);
BLResult blArrayAssignWeak(BLArrayCore* self, const(BLArrayCore)* other);
BLResult blArrayAssignDeep(BLArrayCore* self, const(BLArrayCore)* other);
BLResult blArrayAssignView(BLArrayCore* self, const(void)* items, size_t n);
BLResult blArrayAppendU8(BLArrayCore* self, ubyte value);
BLResult blArrayAppendU16(BLArrayCore* self, ushort value);
BLResult blArrayAppendU32(BLArrayCore* self, uint value);
BLResult blArrayAppendU64(BLArrayCore* self, ulong value);
BLResult blArrayAppendF32(BLArrayCore* self, float value);
BLResult blArrayAppendF64(BLArrayCore* self, double value);
BLResult blArrayAppendItem(BLArrayCore* self, const(void)* item);
BLResult blArrayAppendView(BLArrayCore* self, const(void)* items, size_t n);
BLResult blArrayInsertU8(BLArrayCore* self, size_t index, ubyte value);
BLResult blArrayInsertU16(BLArrayCore* self, size_t index, ushort value);
BLResult blArrayInsertU32(BLArrayCore* self, size_t index, uint value);
BLResult blArrayInsertU64(BLArrayCore* self, size_t index, ulong value);
BLResult blArrayInsertF32(BLArrayCore* self, size_t index, float value);
BLResult blArrayInsertF64(BLArrayCore* self, size_t index, double value);
BLResult blArrayInsertItem(BLArrayCore* self, size_t index, const(void)* item);
BLResult blArrayInsertView(BLArrayCore* self, size_t index, const(void)* items, size_t n);
BLResult blArrayReplaceU8(BLArrayCore* self, size_t index, ubyte value);
BLResult blArrayReplaceU16(BLArrayCore* self, size_t index, ushort value);
BLResult blArrayReplaceU32(BLArrayCore* self, size_t index, uint value);
BLResult blArrayReplaceU64(BLArrayCore* self, size_t index, ulong value);
BLResult blArrayReplaceF32(BLArrayCore* self, size_t index, float value);
BLResult blArrayReplaceF64(BLArrayCore* self, size_t index, double value);
BLResult blArrayReplaceItem(BLArrayCore* self, size_t index, const(void)* item);
BLResult blArrayReplaceView(BLArrayCore* self, size_t rStart, size_t rEnd, const(void)* items, size_t n);
BLResult blArrayRemoveIndex(BLArrayCore* self, size_t index);
BLResult blArrayRemoveRange(BLArrayCore* self, size_t rStart, size_t rEnd);
bool blArrayEquals(const(BLArrayCore)* a, const(BLArrayCore)* b);
//! \}

//! \name BLContext
//!
//! Rendering functionality is provided by \ref BLContextCore in C-API and
//! wrapped by \ref BLContext in C++ API.
//!
//! \{
BLResult blContextInit(BLContextCore* self);
BLResult blContextInitAs(BLContextCore* self, BLImageCore* image, const(BLContextCreateInfo)* options);
BLResult blContextReset(BLContextCore* self);
BLResult blContextAssignMove(BLContextCore* self, BLContextCore* other);
BLResult blContextAssignWeak(BLContextCore* self, const(BLContextCore)* other);
BLResult blContextGetType(const(BLContextCore)* self);
BLResult blContextBegin(BLContextCore* self, BLImageCore* image, const(BLContextCreateInfo)* options);
BLResult blContextEnd(BLContextCore* self);
BLResult blContextFlush(BLContextCore* self, uint flags);
BLResult blContextSave(BLContextCore* self, BLContextCookie* cookie);
BLResult blContextRestore(BLContextCore* self, const(BLContextCookie)* cookie);
BLResult blContextGetMetaMatrix(const(BLContextCore)* self, BLMatrix2D* m);
BLResult blContextGetUserMatrix(const(BLContextCore)* self, BLMatrix2D* m);
BLResult blContextUserToMeta(BLContextCore* self);
BLResult blContextMatrixOp(BLContextCore* self, uint opType, const(void)* opData);
BLResult blContextSetHint(BLContextCore* self, uint hintType, uint value);
BLResult blContextSetHints(BLContextCore* self, const(BLContextHints)* hints);
BLResult blContextSetFlattenMode(BLContextCore* self, uint mode);
BLResult blContextSetFlattenTolerance(BLContextCore* self, double tolerance);
BLResult blContextSetApproximationOptions(BLContextCore* self, const(BLApproximationOptions)* options);
BLResult blContextSetCompOp(BLContextCore* self, uint compOp);
BLResult blContextSetGlobalAlpha(BLContextCore* self, double alpha);
BLResult blContextSetFillAlpha(BLContextCore* self, double alpha);
BLResult blContextGetFillStyle(const(BLContextCore)* self, void* object);
BLResult blContextGetFillStyleRgba32(const(BLContextCore)* self, uint* rgba32);
BLResult blContextGetFillStyleRgba64(const(BLContextCore)* self, ulong* rgba64);
BLResult blContextSetFillStyle(BLContextCore* self, const(void)* object);
BLResult blContextSetFillStyleRgba32(BLContextCore* self, uint rgba32);
BLResult blContextSetFillStyleRgba64(BLContextCore* self, ulong rgba64);
BLResult blContextSetFillRule(BLContextCore* self, uint fillRule);
BLResult blContextSetStrokeAlpha(BLContextCore* self, double alpha);
BLResult blContextGetStrokeStyle(const(BLContextCore)* self, void* object);
BLResult blContextGetStrokeStyleRgba32(const(BLContextCore)* self, uint* rgba32);
BLResult blContextGetStrokeStyleRgba64(const(BLContextCore)* self, ulong* rgba64);
BLResult blContextSetStrokeStyle(BLContextCore* self, const(void)* object);
BLResult blContextSetStrokeStyleRgba32(BLContextCore* self, uint rgba32);
BLResult blContextSetStrokeStyleRgba64(BLContextCore* self, ulong rgba64);
BLResult blContextSetStrokeWidth(BLContextCore* self, double width);
BLResult blContextSetStrokeMiterLimit(BLContextCore* self, double miterLimit);
BLResult blContextSetStrokeCap(BLContextCore* self, uint position, uint strokeCap);
BLResult blContextSetStrokeCaps(BLContextCore* self, uint strokeCap);
BLResult blContextSetStrokeJoin(BLContextCore* self, uint strokeJoin);
BLResult blContextSetStrokeDashOffset(BLContextCore* self, double dashOffset);
BLResult blContextSetStrokeDashArray(BLContextCore* self, const(BLArrayCore)* dashArray);
BLResult blContextSetStrokeTransformOrder(BLContextCore* self, uint transformOrder);
BLResult blContextGetStrokeOptions(const(BLContextCore)* self, BLStrokeOptionsCore* options);
BLResult blContextSetStrokeOptions(BLContextCore* self, const(BLStrokeOptionsCore)* options);
BLResult blContextClipToRectI(BLContextCore* self, const(BLRectI)* rect);
BLResult blContextClipToRectD(BLContextCore* self, const(BLRect)* rect);
BLResult blContextRestoreClipping(BLContextCore* self);
BLResult blContextClearAll(BLContextCore* self);
BLResult blContextClearRectI(BLContextCore* self, const(BLRectI)* rect);
BLResult blContextClearRectD(BLContextCore* self, const(BLRect)* rect);
BLResult blContextFillAll(BLContextCore* self);
BLResult blContextFillRectI(BLContextCore* self, const(BLRectI)* rect);
BLResult blContextFillRectD(BLContextCore* self, const(BLRect)* rect);
BLResult blContextFillPathD(BLContextCore* self, const(BLPathCore)* path);
BLResult blContextFillGeometry(BLContextCore* self, uint geometryType, const(void)* geometryData);
BLResult blContextFillTextI(BLContextCore* self, const(BLPointI)* pt, const(BLFontCore)* font, const(void)* text, size_t size, uint encoding);
BLResult blContextFillTextD(BLContextCore* self, const(BLPoint)* pt, const(BLFontCore)* font, const(void)* text, size_t size, uint encoding);
BLResult blContextFillGlyphRunI(BLContextCore* self, const(BLPointI)* pt, const(BLFontCore)* font, const(BLGlyphRun)* glyphRun);
BLResult blContextFillGlyphRunD(BLContextCore* self, const(BLPoint)* pt, const(BLFontCore)* font, const(BLGlyphRun)* glyphRun);
BLResult blContextStrokeRectI(BLContextCore* self, const(BLRectI)* rect);
BLResult blContextStrokeRectD(BLContextCore* self, const(BLRect)* rect);
BLResult blContextStrokePathD(BLContextCore* self, const(BLPathCore)* path);
BLResult blContextStrokeGeometry(BLContextCore* self, uint geometryType, const(void)* geometryData);
BLResult blContextStrokeTextI(BLContextCore* self, const(BLPointI)* pt, const(BLFontCore)* font, const(void)* text, size_t size, uint encoding);
BLResult blContextStrokeTextD(BLContextCore* self, const(BLPoint)* pt, const(BLFontCore)* font, const(void)* text, size_t size, uint encoding);
BLResult blContextStrokeGlyphRunI(BLContextCore* self, const(BLPointI)* pt, const(BLFontCore)* font, const(BLGlyphRun)* glyphRun);
BLResult blContextStrokeGlyphRunD(BLContextCore* self, const(BLPoint)* pt, const(BLFontCore)* font, const(BLGlyphRun)* glyphRun);
BLResult blContextBlitImageI(BLContextCore* self, const(BLPointI)* pt, const(BLImageCore)* img, const(BLRectI)* imgArea);
BLResult blContextBlitImageD(BLContextCore* self, const(BLPoint)* pt, const(BLImageCore)* img, const(BLRectI)* imgArea);
BLResult blContextBlitScaledImageI(BLContextCore* self, const(BLRectI)* rect, const(BLImageCore)* img, const(BLRectI)* imgArea);
BLResult blContextBlitScaledImageD(BLContextCore* self, const(BLRect)* rect, const(BLImageCore)* img, const(BLRectI)* imgArea);
//! \}

//! \name BLFile
//!
//! File read/write functionality is provided by \ref BLFileCore in C-API and
//! wrapped by \ref BLFile in C++ API.
//!
//! \{
BLResult blFileInit(BLFileCore* self);
BLResult blFileReset(BLFileCore* self);
BLResult blFileOpen(BLFileCore* self, const(char)* fileName, uint openFlags);
BLResult blFileClose(BLFileCore* self);
BLResult blFileSeek(BLFileCore* self, long offset, uint seekType, long* positionOut);
BLResult blFileRead(BLFileCore* self, void* buffer, size_t n, size_t* bytesReadOut);
BLResult blFileWrite(BLFileCore* self, const(void)* buffer, size_t n, size_t* bytesWrittenOut);
BLResult blFileTruncate(BLFileCore* self, long maxSize);
BLResult blFileGetSize(BLFileCore* self, ulong* fileSizeOut);
//! \}

//! \name BLFileSystem
//!
//! Filesystem API is provided by functions prefixed with `blFileSystem` and
//! wrapped by \ref BLFileSystem namespace in C++ API.
//!
//! \{
BLResult blFileSystemReadFile(const(char)* fileName, BLArrayCore* dst, size_t maxSize, uint readFlags);
BLResult blFileSystemWriteFile(const(char)* fileName, const(void)* data, size_t size, size_t* bytesWrittenOut);
//! \}

//! \name BLFont
//!
//! Font functionality is provided by \ref BLFontCore in C-API and wrapped by
//! \ref BLFont in C++ API.
//!
//! \{
BLResult blFontInit(BLFontCore* self);
BLResult blFontReset(BLFontCore* self);
BLResult blFontAssignMove(BLFontCore* self, BLFontCore* other);
BLResult blFontAssignWeak(BLFontCore* self, const(BLFontCore)* other);
bool blFontEquals(const(BLFontCore)* a, const(BLFontCore)* b);
BLResult blFontCreateFromFace(BLFontCore* self, const(BLFontFaceCore)* face, float size);
BLResult blFontShape(const(BLFontCore)* self, BLGlyphBufferCore* gb);
BLResult blFontMapTextToGlyphs(const(BLFontCore)* self, BLGlyphBufferCore* gb, BLGlyphMappingState* stateOut);
BLResult blFontPositionGlyphs(const(BLFontCore)* self, BLGlyphBufferCore* gb, uint positioningFlags);
BLResult blFontApplyKerning(const(BLFontCore)* self, BLGlyphBufferCore* gb);
BLResult blFontApplyGSub(const(BLFontCore)* self, BLGlyphBufferCore* gb, size_t index, BLBitWord lookups);
BLResult blFontApplyGPos(const(BLFontCore)* self, BLGlyphBufferCore* gb, size_t index, BLBitWord lookups);
BLResult blFontGetMatrix(const(BLFontCore)* self, BLFontMatrix* out_);
BLResult blFontGetMetrics(const(BLFontCore)* self, BLFontMetrics* out_);
BLResult blFontGetDesignMetrics(const(BLFontCore)* self, BLFontDesignMetrics* out_);
BLResult blFontGetTextMetrics(const(BLFontCore)* self, BLGlyphBufferCore* gb, BLTextMetrics* out_);
BLResult blFontGetGlyphBounds(const(BLFontCore)* self, const(void)* glyphIdData, intptr_t glyphIdAdvance, BLBoxI* out_, size_t count);
BLResult blFontGetGlyphAdvances(const(BLFontCore)* self, const(void)* glyphIdData, intptr_t glyphIdAdvance, BLGlyphPlacement* out_, size_t count);
BLResult blFontGetGlyphOutlines(const(BLFontCore)* self, uint glyphId, const(BLMatrix2D)* userMatrix, BLPathCore* out_, BLPathSinkFunc sink, void* closure);
BLResult blFontGetGlyphRunOutlines(const(BLFontCore)* self, const(BLGlyphRun)* glyphRun, const(BLMatrix2D)* userMatrix, BLPathCore* out_, BLPathSinkFunc sink, void* closure);
//! \}

//! \name BLFontData
//!
//! Font-data functionality is provided by \ref BLFontDataCore in C-API and
//! wrapped by \ref BLFontData in C++ API.
//!
//! \{
BLResult blFontDataInit(BLFontDataCore* self);
BLResult blFontDataInitFromLoader(BLFontDataCore* self, const(BLFontLoaderCore)* loader, uint faceIndex);
BLResult blFontDataReset(BLFontDataCore* self);
BLResult blFontDataAssignMove(BLFontDataCore* self, BLFontDataCore* other);
BLResult blFontDataAssignWeak(BLFontDataCore* self, const(BLFontDataCore)* other);
BLResult blFontDataCreateFromLoader(BLFontDataCore* self, const(BLFontLoaderCore)* loader, uint faceIndex);
bool blFontDataEquals(const(BLFontDataCore)* a, const(BLFontDataCore)* b);
BLResult blFontDataListTags(const(BLFontDataCore)* self, BLArrayCore* dst);
size_t blFontDataQueryTables(const(BLFontDataCore)* self, BLFontTable* dst, const(BLTag)* tags, size_t count);
//! \}

//! \name BLFontFace
//!
//! Font-face functionality is provided by \ref BLFontFaceCore in C-API and
//! wrapped by \ref BLFontFace in C++ API.
//!
//! \{
BLResult blFontFaceInit(BLFontFaceCore* self);
BLResult blFontFaceReset(BLFontFaceCore* self);
BLResult blFontFaceAssignMove(BLFontFaceCore* self, BLFontFaceCore* other);
BLResult blFontFaceAssignWeak(BLFontFaceCore* self, const(BLFontFaceCore)* other);
bool blFontFaceEquals(const(BLFontFaceCore)* a, const(BLFontFaceCore)* b);
BLResult blFontFaceCreateFromFile(BLFontFaceCore* self, const(char)* fileName, uint readFlags);
BLResult blFontFaceCreateFromLoader(BLFontFaceCore* self, const(BLFontLoaderCore)* loader, uint faceIndex);
BLResult blFontFaceGetFaceInfo(const(BLFontFaceCore)* self, BLFontFaceInfo* out_);
BLResult blFontFaceGetDesignMetrics(const(BLFontFaceCore)* self, BLFontDesignMetrics* out_);
BLResult blFontFaceGetUnicodeCoverage(const(BLFontFaceCore)* self, BLFontUnicodeCoverage* out_);
//! \}

//! \name BLFontLoader
//!
//! Font loading functionality is provided by \ref BLFontLoaderCore in C-API
//! and wrapped by \ref BLFontLoader in C++ API.
//!
//! \{
BLResult blFontLoaderInit(BLFontLoaderCore* self);
BLResult blFontLoaderReset(BLFontLoaderCore* self);
BLResult blFontLoaderAssignMove(BLFontLoaderCore* self, BLFontLoaderCore* other);
BLResult blFontLoaderAssignWeak(BLFontLoaderCore* self, const(BLFontLoaderCore)* other);
bool blFontLoaderEquals(const(BLFontLoaderCore)* a, const(BLFontLoaderCore)* b);
BLResult blFontLoaderCreateFromFile(BLFontLoaderCore* self, const(char)* fileName, uint readFlags);
BLResult blFontLoaderCreateFromDataArray(BLFontLoaderCore* self, const(BLArrayCore)* dataArray);
BLResult blFontLoaderCreateFromData(BLFontLoaderCore* self, const(void)* data, size_t size,
        BLDestroyImplFunc destroyFunc, void* destroyData);
//! \}

//! \name BLFormat
//! \{
BLResult blFormatInfoSanitize(BLFormatInfo* self);
//! \}

//! \name BLGlyphBuffer
//!
//! Glyph-buffer functionality is provided by \ref BLGlyphBufferCore in C-API
//! and wrapped by \ref BLGlyphBuffer in C++ API.
//!
//! \{
BLResult blGlyphBufferInit(BLGlyphBufferCore* self);
BLResult blGlyphBufferInitMove(BLGlyphBufferCore* self, BLGlyphBufferCore* other);
BLResult blGlyphBufferReset(BLGlyphBufferCore* self);
BLResult blGlyphBufferClear(BLGlyphBufferCore* self);
size_t blGlyphBufferGetSize(const(BLGlyphBufferCore)* self);
uint blGlyphBufferGetFlags(const(BLGlyphBufferCore)* self);
const(BLGlyphRun)* blGlyphBufferGetGlyphRun(const(BLGlyphBufferCore)* self);
BLResult blGlyphBufferSetText(BLGlyphBufferCore* self, const(void)* data, size_t size, uint encoding);
BLResult blGlyphBufferSetGlyphIds(BLGlyphBufferCore* self, const(void)* data, intptr_t advance, size_t size);
//! \}

//! \name BLGradient
//!
//! Gradient container is provided by \ref BLGradientCore in C-API and wrapped
//! by \ref BLGradient in C++ API.
//!
//! \{
BLResult blGradientInit(BLGradientCore* self);
BLResult blGradientInitAs(BLGradientCore* self, uint type, const(void)* values, uint extendMode, const(BLGradientStop)* stops, size_t n, const(BLMatrix2D)* m);
BLResult blGradientReset(BLGradientCore* self);
BLResult blGradientAssignMove(BLGradientCore* self, BLGradientCore* other);
BLResult blGradientAssignWeak(BLGradientCore* self, const(BLGradientCore)* other);
BLResult blGradientCreate(BLGradientCore* self, uint type, const(void)* values, uint extendMode, const(BLGradientStop)* stops, size_t n, const(BLMatrix2D)* m);
BLResult blGradientShrink(BLGradientCore* self);
BLResult blGradientReserve(BLGradientCore* self, size_t n);
uint blGradientGetType(const(BLGradientCore)* self);
BLResult blGradientSetType(BLGradientCore* self, uint type);
double blGradientGetValue(const(BLGradientCore)* self, size_t index);
BLResult blGradientSetValue(BLGradientCore* self, size_t index, double value);
BLResult blGradientSetValues(BLGradientCore* self, size_t index, const(double)* values, size_t n);
uint blGradientGetExtendMode(BLGradientCore* self);
BLResult blGradientSetExtendMode(BLGradientCore* self, uint extendMode);
size_t blGradientGetSize(const(BLGradientCore)* self);
size_t blGradientGetCapacity(const(BLGradientCore)* self);
const(BLGradientStop)* blGradientGetStops(const(BLGradientCore)* self);
BLResult blGradientResetStops(BLGradientCore* self);
BLResult blGradientAssignStops(BLGradientCore* self, const(BLGradientStop)* stops, size_t n);
BLResult blGradientAddStopRgba32(BLGradientCore* self, double offset, uint argb32);
BLResult blGradientAddStopRgba64(BLGradientCore* self, double offset, ulong argb64);
BLResult blGradientRemoveStop(BLGradientCore* self, size_t index);
BLResult blGradientRemoveStopByOffset(BLGradientCore* self, double offset, uint all);
BLResult blGradientRemoveStops(BLGradientCore* self, size_t rStart, size_t rEnd);
BLResult blGradientRemoveStopsFromTo(BLGradientCore* self, double offsetMin, double offsetMax);
BLResult blGradientReplaceStopRgba32(BLGradientCore* self, size_t index, double offset, uint rgba32);
BLResult blGradientReplaceStopRgba64(BLGradientCore* self, size_t index, double offset, ulong rgba64);
size_t blGradientIndexOfStop(const(BLGradientCore)* self, double offset);
BLResult blGradientApplyMatrixOp(BLGradientCore* self, uint opType, const(void)* opData);
bool blGradientEquals(const(BLGradientCore)* a, const(BLGradientCore)* b);
//! \}

//! \name BLImage
//!
//! Image container is provided by \ref BLImageCore in C-API and wrapped by
//! \ref BLImage in C++ API.
//!
//! \{
BLResult blImageInit(BLImageCore* self);
BLResult blImageInitAs(BLImageCore* self, int w, int h, uint format);
BLResult blImageInitAsFromData(BLImageCore* self, int w, int h, uint format, void* pixelData, intptr_t stride, BLDestroyImplFunc destroyFunc, void* destroyData);
BLResult blImageReset(BLImageCore* self);
BLResult blImageAssignMove(BLImageCore* self, BLImageCore* other);
BLResult blImageAssignWeak(BLImageCore* self, const(BLImageCore)* other);
BLResult blImageAssignDeep(BLImageCore* self, const(BLImageCore)* other);
BLResult blImageCreate(BLImageCore* self, int w, int h, uint format);
BLResult blImageCreateFromData(BLImageCore* self, int w, int h, uint format, void* pixelData, intptr_t stride, BLDestroyImplFunc destroyFunc, void* destroyData);
BLResult blImageGetData(const(BLImageCore)* self, BLImageData* dataOut);
BLResult blImageMakeMutable(BLImageCore* self, BLImageData* dataOut);
bool blImageEquals(const(BLImageCore)* a, const(BLImageCore)* b);
BLResult blImageScale(BLImageCore* dst, const(BLImageCore)* src, const(BLSizeI)* size, uint filter, const(BLImageScaleOptions)* options);
BLResult blImageReadFromFile(BLImageCore* self, const(char)* fileName, const(BLArrayCore)* codecs);
BLResult blImageReadFromData(BLImageCore* self, const(void)* data, size_t size, const(BLArrayCore)* codecs);
BLResult blImageWriteToFile(const(BLImageCore)* self, const(char)* fileName, const(BLImageCodecCore)* codec);
BLResult blImageWriteToData(const(BLImageCore)* self, BLArrayCore* dst, const(BLImageCodecCore)* codec);
//! \}

//! \name BLImageCodec
//!
//! Image codec functionality is provided by \ref BLImageCodecCore in C-API and
//! wrapped by \ref BLImageCodec in C++ API.
//!
//! \{
BLResult blImageCodecInit(BLImageCodecCore* self);
BLResult blImageCodecReset(BLImageCodecCore* self);
BLResult blImageCodecAssignWeak(BLImageCodecCore* self, const(BLImageCodecCore)* other);
BLResult blImageCodecFindByName(BLImageCodecCore* self, const(char)* name, size_t size, const(BLArrayCore)* codecs);
BLResult blImageCodecFindByData(BLImageCodecCore* self, const(void)* data, size_t size, const(BLArrayCore)* codecs);
uint blImageCodecInspectData(const(BLImageCodecCore)* self, const(void)* data, size_t size);
BLResult blImageCodecCreateDecoder(const(BLImageCodecCore)* self, BLImageDecoderCore* dst);
BLResult blImageCodecCreateEncoder(const(BLImageCodecCore)* self, BLImageEncoderCore* dst);

BLResult blImageCodecArrayInitBuiltInCodecs(BLArrayCore* self);
BLResult blImageCodecArrayAssignBuiltInCodecs(BLArrayCore* self);
BLResult blImageCodecAddToBuiltIn(const(BLImageCodecCore)* codec);
BLResult blImageCodecRemoveFromBuiltIn(const(BLImageCodecCore)* codec);
//! \}

//! \name BLImageDecoder
//!
//! Image decoder functionality is provided by \ref BLImageDecoderCore in C-API
//! and wrapped by \ref BLImageDecoder in C++ API.
//!
//! \{
BLResult blImageDecoderInit(BLImageDecoderCore* self);
BLResult blImageDecoderReset(BLImageDecoderCore* self);
BLResult blImageDecoderAssignMove(BLImageDecoderCore* self, BLImageDecoderCore* other);
BLResult blImageDecoderAssignWeak(BLImageDecoderCore* self, const(BLImageDecoderCore)* other);
BLResult blImageDecoderRestart(BLImageDecoderCore* self);
BLResult blImageDecoderReadInfo(BLImageDecoderCore* self, BLImageInfo* infoOut, const(ubyte)* data, size_t size);
BLResult blImageDecoderReadFrame(BLImageDecoderCore* self, BLImageCore* imageOut, const(ubyte)* data, size_t size);
//! \}

//! \name BLImageEncoder
//!
//! Image encoder functionality is provided by \ref BLImageEncoderCore in C-API
//! and wrapped by \ref BLImageEncoder in C++ API.
//!
//! \{
BLResult blImageEncoderInit(BLImageEncoderCore* self);
BLResult blImageEncoderReset(BLImageEncoderCore* self);
BLResult blImageEncoderAssignMove(BLImageEncoderCore* self, BLImageEncoderCore* other);
BLResult blImageEncoderAssignWeak(BLImageEncoderCore* self, const(BLImageEncoderCore)* other);
BLResult blImageEncoderRestart(BLImageEncoderCore* self);
BLResult blImageEncoderWriteFrame(BLImageEncoderCore* self, BLArrayCore* dst, const(BLImageCore)* image);
//! \}

//! \name BLMatrix2D
//!
//! Matrix functionality is provided by \ref BLMatrix2D, C++ API adds methods to
//! the struct when compiling in C++ mode.
//!
//! \{
BLResult blMatrix2DSetIdentity(BLMatrix2D* self);
BLResult blMatrix2DSetTranslation(BLMatrix2D* self, double x, double y);
BLResult blMatrix2DSetScaling(BLMatrix2D* self, double x, double y);
BLResult blMatrix2DSetSkewing(BLMatrix2D* self, double x, double y);
BLResult blMatrix2DSetRotation(BLMatrix2D* self, double angle, double cx, double cy);
BLResult blMatrix2DApplyOp(BLMatrix2D* self, uint opType, const(void)* opData);
BLResult blMatrix2DInvert(BLMatrix2D* dst, const(BLMatrix2D)* src);
uint blMatrix2DGetType(const(BLMatrix2D)* self);
BLResult blMatrix2DMapPointDArray(const(BLMatrix2D)* self, BLPoint* dst, const(BLPoint)* src, size_t count);
//! \}

//! \name BLPath
//!
//! 2D path functionality is provided by \ref BLPathCore in C-API and wrapped
//! by \ref BLPath in C++ API.
//!
//! \{
BLResult blPathInit(BLPathCore* self);
BLResult blPathReset(BLPathCore* self);
size_t blPathGetSize(const(BLPathCore)* self);
size_t blPathGetCapacity(const(BLPathCore)* self);
const(ubyte)* blPathGetCommandData(const(BLPathCore)* self);
const(BLPoint)* blPathGetVertexData(const(BLPathCore)* self);
BLResult blPathClear(BLPathCore* self);
BLResult blPathShrink(BLPathCore* self);
BLResult blPathReserve(BLPathCore* self, size_t n);
BLResult blPathModifyOp(BLPathCore* self, uint op, size_t n, ubyte** cmdDataOut, BLPoint** vtxDataOut);
BLResult blPathAssignMove(BLPathCore* self, BLPathCore* other);
BLResult blPathAssignWeak(BLPathCore* self, const(BLPathCore)* other);
BLResult blPathAssignDeep(BLPathCore* self, const(BLPathCore)* other);
BLResult blPathSetVertexAt(BLPathCore* self, size_t index, uint cmd, double x, double y);
BLResult blPathMoveTo(BLPathCore* self, double x0, double y0);
BLResult blPathLineTo(BLPathCore* self, double x1, double y1);
BLResult blPathPolyTo(BLPathCore* self, const(BLPoint)* poly, size_t count);
BLResult blPathQuadTo(BLPathCore* self, double x1, double y1, double x2, double y2);
BLResult blPathCubicTo(BLPathCore* self, double x1, double y1, double x2, double y2, double x3, double y3);
BLResult blPathSmoothQuadTo(BLPathCore* self, double x2, double y2);
BLResult blPathSmoothCubicTo(BLPathCore* self, double x2, double y2, double x3, double y3);
BLResult blPathArcTo(BLPathCore* self, double x, double y, double rx, double ry, double start, double sweep, bool forceMoveTo);
BLResult blPathArcQuadrantTo(BLPathCore* self, double x1, double y1, double x2, double y2);
BLResult blPathEllipticArcTo(BLPathCore* self, double rx, double ry, double xAxisRotation, bool largeArcFlag, bool sweepFlag, double x1, double y1);
BLResult blPathClose(BLPathCore* self);
BLResult blPathAddGeometry(BLPathCore* self, uint geometryType, const(void)* geometryData, const(BLMatrix2D)* m, uint dir);
BLResult blPathAddBoxI(BLPathCore* self, const(BLBoxI)* box, uint dir);
BLResult blPathAddBoxD(BLPathCore* self, const(BLBox)* box, uint dir);
BLResult blPathAddRectI(BLPathCore* self, const(BLRectI)* rect, uint dir);
BLResult blPathAddRectD(BLPathCore* self, const(BLRect)* rect, uint dir);
BLResult blPathAddPath(BLPathCore* self, const(BLPathCore)* other, const(BLRange)* range);
BLResult blPathAddTranslatedPath(BLPathCore* self, const(BLPathCore)* other, const(BLRange)* range, const(BLPoint)* p);
BLResult blPathAddTransformedPath(BLPathCore* self, const(BLPathCore)* other, const(BLRange)* range, const(BLMatrix2D)* m);
BLResult blPathAddReversedPath(BLPathCore* self, const(BLPathCore)* other, const(BLRange)* range, uint reverseMode);
BLResult blPathAddStrokedPath(BLPathCore* self, const(BLPathCore)* other, const(BLRange)* range, const(BLStrokeOptionsCore)* options, const(BLApproximationOptions)* approx);
BLResult blPathTranslate(BLPathCore* self, const(BLRange)* range, const(BLPoint)* p);
BLResult blPathTransform(BLPathCore* self, const(BLRange)* range, const(BLMatrix2D)* m);
BLResult blPathFitTo(BLPathCore* self, const(BLRange)* range, const(BLRect)* rect, uint fitFlags);
bool blPathEquals(const(BLPathCore)* a, const(BLPathCore)* b);
BLResult blPathGetInfoFlags(const(BLPathCore)* self, uint* flagsOut);
BLResult blPathGetControlBox(const(BLPathCore)* self, BLBox* boxOut);
BLResult blPathGetBoundingBox(const(BLPathCore)* self, BLBox* boxOut);
BLResult blPathGetFigureRange(const(BLPathCore)* self, size_t index, BLRange* rangeOut);
BLResult blPathGetLastVertex(const(BLPathCore)* self, BLPoint* vtxOut);
BLResult blPathGetClosestVertex(const(BLPathCore)* self, const(BLPoint)* p, double maxDistance, size_t* indexOut, double* distanceOut);
uint blPathHitTest(const(BLPathCore)* self, const(BLPoint)* p, uint fillRule);
//! \}

//! \name BLPattern
//!
//! Pattern functionality is provided by \ref BLPatternCore in C-API and
//! wrapped by \ref BLPattern in C++ API.
//!
//! \{
BLResult blPatternInit(BLPatternCore* self);
BLResult blPatternInitAs(BLPatternCore* self, const(BLImageCore)* image, const(BLRectI)* area, uint extendMode, const(BLMatrix2D)* m);
BLResult blPatternReset(BLPatternCore* self);
BLResult blPatternAssignMove(BLPatternCore* self, BLPatternCore* other);
BLResult blPatternAssignWeak(BLPatternCore* self, const(BLPatternCore)* other);
BLResult blPatternAssignDeep(BLPatternCore* self, const(BLPatternCore)* other);
BLResult blPatternCreate(BLPatternCore* self, const(BLImageCore)* image, const(BLRectI)* area, uint extendMode, const(BLMatrix2D)* m);
BLResult blPatternSetImage(BLPatternCore* self, const(BLImageCore)* image, const(BLRectI)* area);
BLResult blPatternSetArea(BLPatternCore* self, const(BLRectI)* area);
BLResult blPatternSetExtendMode(BLPatternCore* self, uint extendMode);
BLResult blPatternApplyMatrixOp(BLPatternCore* self, uint opType, const(void)* opData);
bool blPatternEquals(const(BLPatternCore)* a, const(BLPatternCore)* b);
//! \}

//! \name BLPixelConverter
//!
//! Pixel conversion functionality is provided by \ref BLPixelConverterCore
//! in C-API and wrapped by \ref BLPixelConverter in C++ API.
//!
//! \{
BLResult blPixelConverterInit(BLPixelConverterCore* self);
BLResult blPixelConverterInitWeak(BLPixelConverterCore* self, const(BLPixelConverterCore)* other);
BLResult blPixelConverterReset(BLPixelConverterCore* self);
BLResult blPixelConverterAssign(BLPixelConverterCore* self, const(BLPixelConverterCore)* other);
BLResult blPixelConverterCreate(BLPixelConverterCore* self, const(BLFormatInfo)* dstInfo, const(BLFormatInfo)* srcInfo);

BLResult blPixelConverterConvert(const(BLPixelConverterCore)* self, void* dstData, intptr_t dstStride,
        const(void)* srcData, intptr_t srcStride, uint w, uint h, const(BLPixelConverterOptions)* options);
//! \}

//! \name BLRandom
//! \{
void blRandomReset(BLRandom* self, ulong seed);
uint blRandomNextUInt32(BLRandom* self);
ulong blRandomNextUInt64(BLRandom* self);
double blRandomNextDouble(BLRandom* self);
//! \}

//! \name BLRegion
//!
//! 2D region functionality is provided by \ref BLRegionCore in C-API and
//! wrapped by \ref BLRegion in C++ API.
//!
//! \{
BLResult blRegionInit(BLRegionCore* self);
BLResult blRegionReset(BLRegionCore* self);
size_t blRegionGetSize(const(BLRegionCore)* self);
size_t blRegionGetCapacity(const(BLRegionCore)* self);
const(BLBoxI)* blRegionGetData(const(BLRegionCore)* self);
BLResult blRegionClear(BLRegionCore* self);
BLResult blRegionShrink(BLRegionCore* self);
BLResult blRegionReserve(BLRegionCore* self, size_t n);
BLResult blRegionAssignMove(BLRegionCore* self, BLRegionCore* other);
BLResult blRegionAssignWeak(BLRegionCore* self, const(BLRegionCore)* other);
BLResult blRegionAssignDeep(BLRegionCore* self, const(BLRegionCore)* other);
BLResult blRegionAssignBoxI(BLRegionCore* self, const(BLBoxI)* src);
BLResult blRegionAssignBoxIArray(BLRegionCore* self, const(BLBoxI)* data, size_t n);
BLResult blRegionAssignRectI(BLRegionCore* self, const(BLRectI)* rect);
BLResult blRegionAssignRectIArray(BLRegionCore* self, const(BLRectI)* data, size_t n);
BLResult blRegionCombine(BLRegionCore* self, const(BLRegionCore)* a, const(BLRegionCore)* b, uint op);
BLResult blRegionCombineRB(BLRegionCore* self, const(BLRegionCore)* a, const(BLBoxI)* b, uint op);
BLResult blRegionCombineBR(BLRegionCore* self, const(BLBoxI)* a, const(BLRegionCore)* b, uint op);
BLResult blRegionCombineBB(BLRegionCore* self, const(BLBoxI)* a, const(BLBoxI)* b, uint op);
BLResult blRegionTranslate(BLRegionCore* self, const(BLRegionCore)* r, const(BLPointI)* pt);
BLResult blRegionTranslateAndClip(BLRegionCore* self, const(BLRegionCore)* r, const(BLPointI)* pt, const(BLBoxI)* clipBox);
BLResult blRegionIntersectAndClip(BLRegionCore* self, const(BLRegionCore)* a, const(BLRegionCore)* b, const(BLBoxI)* clipBox);
bool blRegionEquals(const(BLRegionCore)* a, const(BLRegionCore)* b);
uint blRegionGetType(const(BLRegionCore)* self);
uint blRegionHitTest(const(BLRegionCore)* self, const(BLPointI)* pt);
uint blRegionHitTestBoxI(const(BLRegionCore)* self, const(BLBoxI)* box);
//! \}

//! \name BLRuntime
//!
//! Blend2D runtime functions are provided either as a C-API or wrapped by
//! \ref BLRuntime namespace in C++ API.
//!
//! \{
BLResult blRuntimeInit();
BLResult blRuntimeShutdown();
BLResult blRuntimeCleanup(uint cleanupFlags);
BLResult blRuntimeQueryInfo(uint infoType, void* infoOut);
BLResult blRuntimeMessageOut(const(char)* msg);
BLResult blRuntimeMessageFmt(const(char)* fmt, ...);
BLResult blRuntimeMessageVFmt(const(char)* fmt, va_list ap);
uint blRuntimeGetTickCount();

void blRuntimeAssertionFailure(const(char)* file, int line, const(char)* msg);

BLResult blResultFromWinError(uint e);

//! \}

//! \name BLString
//!
//! String contanter is provided by \ref BLStringCore in C-API and wrapped by
//! \ref BLString in C++ API.
//!
//! \{
BLResult blStringInit(BLStringCore* self);
BLResult blStringReset(BLStringCore* self);
size_t blStringGetSize(const(BLStringCore)* self);
size_t blStringGetCapacity(const(BLStringCore)* self);
const(char)* blStringGetData(const(BLStringCore)* self);
BLResult blStringClear(BLStringCore* self);
BLResult blStringShrink(BLStringCore* self);
BLResult blStringReserve(BLStringCore* self, size_t n);
BLResult blStringResize(BLStringCore* self, size_t n, char fill);
BLResult blStringMakeMutable(BLStringCore* self, char** dataOut);
BLResult blStringModifyOp(BLStringCore* self, uint op, size_t n, char** dataOut);
BLResult blStringInsertOp(BLStringCore* self, size_t index, size_t n, char** dataOut);
BLResult blStringAssignMove(BLStringCore* self, BLStringCore* other);
BLResult blStringAssignWeak(BLStringCore* self, const(BLStringCore)* other);
BLResult blStringAssignDeep(BLStringCore* self, const(BLStringCore)* other);
BLResult blStringAssignData(BLStringCore* self, const(char)* str, size_t n);
BLResult blStringApplyOpChar(BLStringCore* self, uint op, char c, size_t n);
BLResult blStringApplyOpData(BLStringCore* self, uint op, const(char)* str, size_t n);
BLResult blStringApplyOpString(BLStringCore* self, uint op, const(BLStringCore)* other);
BLResult blStringApplyOpFormat(BLStringCore* self, uint op, const(char)* fmt, ...);
BLResult blStringApplyOpFormatV(BLStringCore* self, uint op, const(char)* fmt, va_list ap);
BLResult blStringInsertChar(BLStringCore* self, size_t index, char c, size_t n);
BLResult blStringInsertData(BLStringCore* self, size_t index, const(char)* str, size_t n);
BLResult blStringInsertString(BLStringCore* self, size_t index, const(BLStringCore)* other);
BLResult blStringRemoveRange(BLStringCore* self, size_t rStart, size_t rEnd);
bool blStringEquals(const(BLStringCore)* self, const(BLStringCore)* other);
bool blStringEqualsData(const(BLStringCore)* self, const(char)* str, size_t n);
int blStringCompare(const(BLStringCore)* self, const(BLStringCore)* other);
int blStringCompareData(const(BLStringCore)* self, const(char)* str, size_t n);
//! \}

//! \name BLStrokeOptions
//!
//! Stroke options are provided by \ref BLStrokeOptionsCore in C-API and
//! wrapped by \ref BLStrokeOptions in C++ API.
//!
//! \{
BLResult blStrokeOptionsInit(BLStrokeOptionsCore* self);
BLResult blStrokeOptionsInitMove(BLStrokeOptionsCore* self, BLStrokeOptionsCore* other);
BLResult blStrokeOptionsInitWeak(BLStrokeOptionsCore* self, const(BLStrokeOptionsCore)* other);
BLResult blStrokeOptionsReset(BLStrokeOptionsCore* self);
BLResult blStrokeOptionsAssignMove(BLStrokeOptionsCore* self, BLStrokeOptionsCore* other);
BLResult blStrokeOptionsAssignWeak(BLStrokeOptionsCore* self, const(BLStrokeOptionsCore)* other);
//! \}

//! \name BLVariant
//!
//! Variant C-API can be used on any object compatible with Blend2D Impl, at
//! the moment only \ref BLStrokeOptionsCore and \ref BLGlyphBufferCore are
//! not compatible, all others are.
//!
//! \{
BLResult blVariantInit(void* self);
BLResult blVariantInitMove(void* self, void* other);
BLResult blVariantInitWeak(void* self, const(void)* other);
BLResult blVariantReset(void* self);
uint blVariantGetImplType(const(void)* self);
BLResult blVariantAssignMove(void* self, void* other);
BLResult blVariantAssignWeak(void* self, const(void)* other);
bool blVariantEquals(const(void)* a, const(void)* b);
//! \}

//! \}
