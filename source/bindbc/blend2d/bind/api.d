// [Blend2D]
module bindbc.blend2d.bind.api;

import core.stdc.stddef;
import core.stdc.string;
import core.stdc.stdint;
import core.stdc.stdarg;

import bindbc.blend2d.bind.path;
import bindbc.blend2d.bind.geometry;
import bindbc.blend2d.bind.array;
import bindbc.blend2d.bind.context;
import bindbc.blend2d.bind.image;
import bindbc.blend2d.bind.matrix;
import bindbc.blend2d.bind.font;
import bindbc.blend2d.bind.fontdefs;
import bindbc.blend2d.bind.filesystem;
import bindbc.blend2d.bind.glyphbuffer;
import bindbc.blend2d.bind.format;
import bindbc.blend2d.bind.gradient;
import bindbc.blend2d.bind.pattern;
import bindbc.blend2d.bind.pixelconverter;
import bindbc.blend2d.bind.random;
import bindbc.blend2d.bind.region;
import bindbc.blend2d.bind.string;

//extern (System):

// 2D Vector Graphics Powered by a JIT Compiler.
//
// [License]
// Zlib - See LICENSE.md file in the package.

// This header can only be included by either <blend2d.h> or by Blend2D headers
// during the build. Prevent users including <blend2d/> headers by accident and
// prevent not including "blend2d/blapi-build_p.h" during the build.
// Include either <blend2d.h> or <blend2d-impl.h> to use Blend2D library.

// ----------------------------------------------------------------------------
// [Documentation]
// ----------------------------------------------------------------------------

//! \mainpage API Reference
//!
//! Blend2D C/C++ API reference documentation generated by Doxygen.
//!
//! \section main_introduction Introduction
//!
//! Blend2D API consists of enumerations, functions, structs, and C++ classes.
//! Common concepts like enumerations and POD structs are shared between C and
//! C++. Some structs contain extra functionality like `BLSomething::reset()`
//! that is only available to C++ users, however, such functionality is only
//! provided for convenience and doesn't affect how Blend2D can be used from C.
//!
//! Blend2D C++ API is in fact build on top of the C API and all C++ functions
//! are inlines that call C API without any overhead. It would require double
//! effort to document both C and C++ APIs separately so we have decided to only
//! document C++ API and to only list \ref blend2d_api_c_functions "C API" for
//! users that need it. The C API should be straightforward and matches very
//! well the C++ part.
//!
//! \section main_important Important
//!
//! Doxygen sorts struct members in anonymous structs and unions and we haven't
//! figured out how to turn this off. This means that the order of members in
//! "Public Attributes" doesn't have to reflect the original struct packing.
//! So please always double-check struct members in case you plan to use
//! braces-based initialization of simple structs.
//!
//! \section main_groups Groups
//!
//! The documentation is split into the following groups:
//!
//! $$DOCS_GROUP_OVERVIEW$$
//!
//! \section main_other Other Pages
//!
//!   - <a href="../doc/getting-started.html">Getting Started</a> - Covers basic
//!     setup and few sample applications
//!   - <a href="annotated.html">Class List</a> - Provides a list of classes
//!     sorted alphabetically

//! \defgroup blend2d_api_globals Global API
//! \brief Global functions, constants,  and classes used universally across
//! the library.

//! \defgroup blend2d_api_geometry Geometry API
//! \brief Geometries, paths, and transformations.
//!
//! Blend2D offers various geometry structures and objects that can be used with
//! either `BLPath` for path building or `BLContext` for rendering.

//! \defgroup blend2d_api_imaging Imaging API
//! \brief Images and image codecs.

//! \defgroup blend2d_api_styling Styling API
//! \brief Colors, gradients, and patterns.

//! \defgroup blend2d_api_text Text API
//! \brief Fonts & Text support.

//! \defgroup blend2d_api_rendering Rendering API
//! \brief 2D rendering context, helper structures, and constants.

//! \defgroup blend2d_api_runtime Runtime API
//! \brief Interaction with Blend2D runtime.

//! \defgroup blend2d_api_filesystem Filesystem API
//! \brief Filesystem utilities.

//! \defgroup blend2d_api_impl Impl API
//! \brief API required for extending Blend2D functionality.
//!
//! Everything that is part of this group requires `<blend2d-impl.h>` to be
//! included before the use as this API is only for users that extend Blend2D.

//! \defgroup blend2d_api_macros Macros
//! \brief Preprocessor macros and compile-time constants.

//! \defgroup blend2d_api_c_functions C API
//! \brief Global C API functions exported as `extern "C"` (C API).
//!
//! We do not document these functions as they are called from C++ wrappers,
//! which are documented and should be used as a reference. The most important
//! thing in using C API is to understand how lifetime of objects is managed.
//!
//! Each type that requires initialization provides `Init` and `Reset` functions.
//! These functions are called by C++ constructors and destructors on C++ side
//! and must be used the same way by C users. Although these functions return
//! `BLResult` it's guaranteed the result is always `BL_SUCCESS` - the return
//! value is only provided for consistency and possible tail calling.
//!
//! The following example should illustrate how `Init` and `Reset` works:
//!
//! ```
//! BLImageCore img;
//! blImageInit(&img);
//! blImageCreate(&img, 128, 128, BL_FORMAT_PRGB32);
//! blImageReset(&img);
//! ```
//!
//! Some init functions may provide shortcuts for the most used scenarios that
//! merge initialization and resource allocation into a single function.
//!
//! ```
//! BLImageCore img;
//! blImageInitAs(&img, 128, 128, BL_FORMAT_PRGB32);
//! blImageReset(&img);
//! ```
//!
//! It's worth knowing that default initialization in Blend2D costs nothing
//! and no resources are allocated, thus initialization never fails and in
//! theory default initialized objects don't have to be reset as they don't
//! hold any data (however never do that in practice). Resetting always resets
//! the object into its default initialized form, so you can reuse such object
//! afterwards (after reset it's still properly initialized) or consider it
//! destroyed.
//!
//! The following example should explain how init/reset works:
//!
//! \code
//! BLImageCore img;
//!
//! // Now image is default constructed/initialized. if you did just this and
//! // abandon it then no resources will be leaked as default construction is
//! // not allocating any resources nor increasing any reference counters.
//! blImageInit(&img);
//!
//! // Now image will have to dynamically allocate some memory to store pixel
//! // data. If this succeeds the image will have to be reset to destroy the
//! // data it holds.
//! BLResult result = blImageCreate(&img, 128, 128, BL_FORMAT_PRGB32);
//! if (result != BL_SUCCESS) {
//!   // If function fails it should behave like it was never called, so `img`
//!   // would still be default initialized in this case. this means that you
//!   // don't have to reset it explicitly although the C++ API would do it in
//!   // image destructor.
//!   return result;
//! }
//!
//! // Resetting image would destroy its data and make it default constructed.
//! blImageReset(&img);
//!
//! // You can still use the image after it has been reset as the data it holds
//! // is still valid, but the image is of course empty.
//! printf("%d", blImageEquals(&img, &img));
//! \endcode

//! \cond INTERNAL

//! \defgroup blend2d_internal Internal
//!
//! \brief Internal API.

//! \defgroup blend2d_internal_codecs Codecs
//!
//! \brief Codecs implementation.

//! \defgroup blend2d_internal_raster Raster
//!
//! \brief Raster rendering context.

//! \defgroup blend2d_internal_pipegen PipeGen
//!
//! \brief Pipeline generator.

//! \defgroup blend2d_internal_opentype OpenType
//!
//! \brief OpenType implementation.

//! \endcond

// ============================================================================
// [Version]
// ============================================================================

//! \addtogroup blend2d_api_macros
//! \{

//! \name Version Information
//! \{

//! Makes a version number representing a `MAJOR.MINOR.PATCH` combination.
extern (D) auto BL_MAKE_VERSION(T0, T1, T2)(auto ref T0 MAJOR, auto ref T1 MINOR, auto ref T2 PATCH) {
    return (MAJOR << 16) | (MINOR << 8) | PATCH;
}

//! Blend2D library version.
enum BL_VERSION = BL_MAKE_VERSION(0, 0, 1);

//! \}

//! \}

// ============================================================================
// [Public Macros]
// ============================================================================

//! \addtogroup blend2d_api_macros
//! \{

//! \name Target Information
//! \{

//! \def BL_BYTE_ORDER
//!
//! A compile-time constant (macro) that defines byte-order of the target. It
//! can be either `1234` for little-endian targets or `4321` for big-endian
//! targets. Blend2D uses this macro internally, but it's also available to
//! end users as sometimes it could be important for deciding between pixel
//! formats or other important details.

enum BL_BYTE_ORDER = 1234;

//! \}

//! \name Utilities
//! \{

//! Creates a 32-bit tag (uint32_t) from the given `A`, `B`, `C`, and `D` values.
extern (D) auto BL_MAKE_TAG(T0, T1, T2, T3)(auto ref T0 A, auto ref T1 B, auto ref T2 C, auto ref T3 D) {
    return cast(BLTag)(cast(BLTag) A << 24) | (cast(BLTag) B << 16) | (cast(BLTag) C << 8) | (cast(BLTag) D);
}

//! \}

//! \}

// ============================================================================
// [Public Types]
// ============================================================================

//! \ingroup blend2d_api_globals
//!
//! Result code used by most Blend2D functions (32-bit unsigned integer).
//!
//! The `BLResultCode` enumeration contains Blend2D result codes that contain
//! Blend2D specific set of errors and an extended set of errors that can come
//! from WIN32 or POSIX APIs. Since the success result code is zero it's
//! recommended to use the following check to determine whether a call failed
//! or not:
//!
//! ```
//! BLResult result = doSomething();
//! if (result != BL_SUCCESS) {
//!   // `doSomething()` failed...
//! }
//! ```
alias BLResult = uint;

//! \ingroup blend2d_api_globals
//!
//! A type used to store a pack of bits (typedef to `uintptr_t`).
//!
//! BitWord should be equal in size to a machine word.
alias BLBitWord = ulong;

//! \ingroup blend2d_api_globals
//!
//! Tag is a 32-bit integer consisting of 4 characters in the following format:
//!
//! ```
//! tag = ((a << 24) | (b << 16) | (c << 8) | d)
//! ```
//!
//! Tags are used extensively by OpenType fonts and other binary formats like
//! PNG. In most cases TAGs should only contain ASCII letters, digits, and spaces.
//!
//! Blend2D uses `BLTag` in public and internal APIs to distinguish between a
//! regular `uint32_t` and tag.
alias BLTag = uint;

//! \ingroup blend2d_api_globals
//!
//! A function callback that is called when an Impl is destroyed. It's often used
//! to notify that a data passed to a certain Impl is no longer in use.
alias BLDestroyImplFunc = void function(void* impl, void* destroyData);

//! \ingroup blend2d_api_geometry
//!
//! Optional callback that can be used to consume a path data.
alias BLPathSinkFunc = uint function(BLPathCore* path, const(void)* info, void* closure);

//! \ingroup blend2d_api_text
//!
//! Glyph identifier is an index to a glyph stored in a font.
//!
//! GlyphId is always an unsigned 16-bit integer as used by TrueType and OpenType
//! fonts. There are some libraries that use 32-bit integers for Glyph indexes,
//! but values above 65535 are never used in practice as font's generally do
//! not have the ability to index more than 65535 glyphs (excluding null glyph).
alias BLGlyphId = ushort;

// ============================================================================
// [Constants]
// ============================================================================

//! \ingroup blend2d_api_globals
//!
//! Blend2D result code.
enum BLResultCode {
    //! Successful result code.
    BL_SUCCESS = 0,

    BL_ERROR_START_INDEX = 0x00010000u,

    BL_ERROR_OUT_OF_MEMORY = 0x00010000u, //!< Out of memory                 [ENOMEM].
    BL_ERROR_INVALID_VALUE = 65537, //!< Invalid value/argument        [EINVAL].
    BL_ERROR_INVALID_STATE = 65538, //!< Invalid state                 [EFAULT].
    BL_ERROR_INVALID_HANDLE = 65539, //!< Invalid handle or file.       [EBADF].
    BL_ERROR_VALUE_TOO_LARGE = 65540, //!< Value too large               [EOVERFLOW].
    BL_ERROR_NOT_INITIALIZED = 65541, //!< Not initialized (some instance is built-in none when it shouldn't be).
    BL_ERROR_NOT_IMPLEMENTED = 65542, //!< Not implemented               [ENOSYS].
    BL_ERROR_NOT_PERMITTED = 65543, //!< Operation not permitted       [EPERM].

    BL_ERROR_IO = 65544, //!< IO error                      [EIO].
    BL_ERROR_BUSY = 65545, //!< Device or resource busy       [EBUSY].
    BL_ERROR_INTERRUPTED = 65546, //!< Operation interrupted         [EINTR].
    BL_ERROR_TRY_AGAIN = 65547, //!< Try again                     [EAGAIN].
    BL_ERROR_TIMED_OUT = 65548, //!< Timed out                     [ETIMEDOUT].
    BL_ERROR_BROKEN_PIPE = 65549, //!< Broken pipe                   [EPIPE].
    BL_ERROR_INVALID_SEEK = 65550, //!< File is not seekable          [ESPIPE].
    BL_ERROR_SYMLINK_LOOP = 65551, //!< Too many levels of symlinks   [ELOOP].
    BL_ERROR_FILE_TOO_LARGE = 65552, //!< File is too large             [EFBIG].
    BL_ERROR_ALREADY_EXISTS = 65553, //!< File/directory already exists [EEXIST].
    BL_ERROR_ACCESS_DENIED = 65554, //!< Access denied                 [EACCES].
    BL_ERROR_MEDIA_CHANGED = 65555, //!< Media changed                 [Windows::ERROR_MEDIA_CHANGED].
    BL_ERROR_READ_ONLY_FS = 65556, //!< The file/FS is read-only      [EROFS].
    BL_ERROR_NO_DEVICE = 65557, //!< Device doesn't exist          [ENXIO].
    BL_ERROR_NO_ENTRY = 65558, //!< Not found, no entry (fs)      [ENOENT].
    BL_ERROR_NO_MEDIA = 65559, //!< No media in drive/device      [ENOMEDIUM].
    BL_ERROR_NO_MORE_DATA = 65560, //!< No more data / end of file    [ENODATA].
    BL_ERROR_NO_MORE_FILES = 65561, //!< No more files                 [ENMFILE].
    BL_ERROR_NO_SPACE_LEFT = 65562, //!< No space left on device       [ENOSPC].
    BL_ERROR_NOT_EMPTY = 65563, //!< Directory is not empty        [ENOTEMPTY].
    BL_ERROR_NOT_FILE = 65564, //!< Not a file                    [EISDIR].
    BL_ERROR_NOT_DIRECTORY = 65565, //!< Not a directory               [ENOTDIR].
    BL_ERROR_NOT_SAME_DEVICE = 65566, //!< Not same device               [EXDEV].
    BL_ERROR_NOT_BLOCK_DEVICE = 65567, //!< Not a block device            [ENOTBLK].

    BL_ERROR_INVALID_FILE_NAME = 65568, //!< File/path name is invalid     [n/a].
    BL_ERROR_FILE_NAME_TOO_LONG = 65569, //!< File/path name is too long    [ENAMETOOLONG].

    BL_ERROR_TOO_MANY_OPEN_FILES = 65570, //!< Too many open files           [EMFILE].
    BL_ERROR_TOO_MANY_OPEN_FILES_BY_OS = 65571, //!< Too many open files by OS     [ENFILE].
    BL_ERROR_TOO_MANY_LINKS = 65572, //!< Too many symbolic links on FS [EMLINK].
    BL_ERROR_TOO_MANY_THREADS = 65573, //!< Too many threads              [EAGAIN].

    BL_ERROR_FILE_EMPTY = 65574, //!< File is empty (not specific to any OS error).
    BL_ERROR_OPEN_FAILED = 65575, //!< File open failed              [Windows::ERROR_OPEN_FAILED].
    BL_ERROR_NOT_ROOT_DEVICE = 65576, //!< Not a root device/directory   [Windows::ERROR_DIR_NOT_ROOT].

    BL_ERROR_UNKNOWN_SYSTEM_ERROR = 65577, //!< Unknown system error that failed to translate to Blend2D result code.

    BL_ERROR_INVALID_ALIGNMENT = 65578, //!< Invalid data alignment.
    BL_ERROR_INVALID_SIGNATURE = 65579, //!< Invalid data signature or header.
    BL_ERROR_INVALID_DATA = 65580, //!< Invalid or corrupted data.
    BL_ERROR_INVALID_STRING = 65581, //!< Invalid string (invalid data of either UTF8, UTF16, or UTF32).
    BL_ERROR_DATA_TRUNCATED = 65582, //!< Truncated data (more data required than memory/stream provides).
    BL_ERROR_DATA_TOO_LARGE = 65583, //!< Input data too large to be processed.
    BL_ERROR_DECOMPRESSION_FAILED = 65584, //!< Decompression failed due to invalid data (RLE, Huffman, etc).

    BL_ERROR_INVALID_GEOMETRY = 65585, //!< Invalid geometry (invalid path data or shape).
    BL_ERROR_NO_MATCHING_VERTEX = 65586, //!< Returned when there is no matching vertex in path data.

    BL_ERROR_NO_MATCHING_COOKIE = 65587, //!< No matching cookie (BLContext).
    BL_ERROR_NO_STATES_TO_RESTORE = 65588, //!< No states to restore (BLContext).

    BL_ERROR_IMAGE_TOO_LARGE = 65589, //!< The size of the image is too large.
    BL_ERROR_IMAGE_NO_MATCHING_CODEC = 65590, //!< Image codec for a required format doesn't exist.
    BL_ERROR_IMAGE_UNKNOWN_FILE_FORMAT = 65591, //!< Unknown or invalid file format that cannot be read.
    BL_ERROR_IMAGE_DECODER_NOT_PROVIDED = 65592, //!< Image codec doesn't support reading the file format.
    BL_ERROR_IMAGE_ENCODER_NOT_PROVIDED = 65593, //!< Image codec doesn't support writing the file format.

    BL_ERROR_PNG_MULTIPLE_IHDR = 65594, //!< Multiple IHDR chunks are not allowed (PNG).
    BL_ERROR_PNG_INVALID_IDAT = 65595, //!< Invalid IDAT chunk (PNG).
    BL_ERROR_PNG_INVALID_IEND = 65596, //!< Invalid IEND chunk (PNG).
    BL_ERROR_PNG_INVALID_PLTE = 65597, //!< Invalid PLTE chunk (PNG).
    BL_ERROR_PNG_INVALID_TRNS = 65598, //!< Invalid tRNS chunk (PNG).
    BL_ERROR_PNG_INVALID_FILTER = 65599, //!< Invalid filter type (PNG).

    BL_ERROR_JPEG_UNSUPPORTED_FEATURE = 65600, //!< Unsupported feature (JPEG).
    BL_ERROR_JPEG_INVALID_SOS = 65601, //!< Invalid SOS marker or header (JPEG).
    BL_ERROR_JPEG_INVALID_SOF = 65602, //!< Invalid SOF marker (JPEG).
    BL_ERROR_JPEG_MULTIPLE_SOF = 65603, //!< Multiple SOF markers (JPEG).
    BL_ERROR_JPEG_UNSUPPORTED_SOF = 65604, //!< Unsupported SOF marker (JPEG).

    BL_ERROR_FONT_NO_CHARACTER_MAPPING = 65605, //!< Font has no character to glyph mapping data.
    BL_ERROR_FONT_MISSING_IMPORTANT_TABLE = 65606, //!< Font has missing an important table.
    BL_ERROR_FONT_FEATURE_NOT_AVAILABLE = 65607, //!< Font feature is not available.
    BL_ERROR_FONT_CFF_INVALID_DATA = 65608, //!< Font has an invalid CFF data.
    BL_ERROR_FONT_PROGRAM_TERMINATED = 65609, //!< Font program terminated because the execution reached the limit.

    BL_ERROR_INVALID_GLYPH = 65610 //!< Invalid glyph identifier.
}

//! \ingroup blend2d_api_globals
//!
//! Byte order.
enum BLByteOrder {
    //! Little endian byte-order.
    BL_BYTE_ORDER_LE = 0,
    //! Big endian byte-order.
    BL_BYTE_ORDER_BE = 1,

    //! Native (host) byte-order.
    BL_BYTE_ORDER_NATIVE = BL_BYTE_ORDER == 1234 ? BL_BYTE_ORDER_LE : BL_BYTE_ORDER_BE,
    //! Swapped byte-order (BE if host is LE and vice versa).
    BL_BYTE_ORDER_SWAPPED = BL_BYTE_ORDER == 1234 ? BL_BYTE_ORDER_BE : BL_BYTE_ORDER_LE
}

//! \ingroup blend2d_api_globals
//!
//! Data access flags.
enum BLDataAccessFlags {
    //! Read access.
    BL_DATA_ACCESS_READ = 0x01u,
    //! Write access.
    BL_DATA_ACCESS_WRITE = 0x02u,
    //! Read and write access.
    BL_DATA_ACCESS_RW = 0x03u
}

//! \ingroup blend2d_api_globals
//!
//! Data source type.
enum BLDataSourceType {
    //! No data source.
    BL_DATA_SOURCE_TYPE_NONE = 0,
    //! Memory data source.
    BL_DATA_SOURCE_TYPE_MEMORY = 1,
    //! File data source.
    BL_DATA_SOURCE_TYPE_FILE = 2,
    //! Custom data source.
    BL_DATA_SOURCE_TYPE_CUSTOM = 3,

    //! Count of data source types.
    BL_DATA_SOURCE_TYPE_COUNT = 4
}

//! \ingroup blend2d_api_globals
//!
//! Modification operation applied to Blend2D containers.
enum BLModifyOp {
    //! Assign operation and reserve only space to fit the input.
    BL_MODIFY_OP_ASSIGN_FIT = 0,
    //! Assign operation and reserve more capacity for growing.
    BL_MODIFY_OP_ASSIGN_GROW = 1,
    //! Append operation and reserve only space to fit the input.
    BL_MODIFY_OP_APPEND_FIT = 2,
    //! Append operation and reserve more capacity for growing.
    BL_MODIFY_OP_APPEND_GROW = 3,

    //! Count of data operations.
    BL_MODIFY_OP_COUNT = 4
}

//! \ingroup blend2d_api_globals
//!
//! Boolean operator.
enum BLBooleanOp {
    //! Result = B.
    BL_BOOLEAN_OP_COPY = 0,
    //! Result = A & B.
    BL_BOOLEAN_OP_AND = 1,
    //! Result = A | B.
    BL_BOOLEAN_OP_OR = 2,
    //! Result = A ^ B.
    BL_BOOLEAN_OP_XOR = 3,
    //! Result = A & ~B.
    BL_BOOLEAN_OP_SUB = 4,

    //! Count of boolean operations.
    BL_BOOLEAN_OP_COUNT = 5
}

//! \ingroup blend2d_api_styling
//!
//! Extend mode.
enum BLExtendMode {
    //! Pad extend [default].
    BL_EXTEND_MODE_PAD = 0,
    //! Repeat extend.
    BL_EXTEND_MODE_REPEAT = 1,
    //! Reflect extend.
    BL_EXTEND_MODE_REFLECT = 2,

    //! Alias to `BL_EXTEND_MODE_PAD`.
    BL_EXTEND_MODE_PAD_X_PAD_Y = 0,
    //! Alias to `BL_EXTEND_MODE_REPEAT`.
    BL_EXTEND_MODE_REPEAT_X_REPEAT_Y = 1,
    //! Alias to `BL_EXTEND_MODE_REFLECT`.
    BL_EXTEND_MODE_REFLECT_X_REFLECT_Y = 2,
    //! Pad X and repeat Y.
    BL_EXTEND_MODE_PAD_X_REPEAT_Y = 3,
    //! Pad X and reflect Y.
    BL_EXTEND_MODE_PAD_X_REFLECT_Y = 4,
    //! Repeat X and pad Y.
    BL_EXTEND_MODE_REPEAT_X_PAD_Y = 5,
    //! Repeat X and reflect Y.
    BL_EXTEND_MODE_REPEAT_X_REFLECT_Y = 6,
    //! Reflect X and pad Y.
    BL_EXTEND_MODE_REFLECT_X_PAD_Y = 7,
    //! Reflect X and repeat Y.
    BL_EXTEND_MODE_REFLECT_X_REPEAT_Y = 8,

    //! Count of simple extend modes (that use the same value for X and Y).
    BL_EXTEND_MODE_SIMPLE_COUNT = 3,
    //! Count of complex extend modes (that can use independent values for X and Y).
    BL_EXTEND_MODE_COMPLEX_COUNT = 9
}

//! \ingroup blend2d_api_styling
//!
//! Style type.
enum BLStyleType {
    //! No style, nothing will be paint.
    BL_STYLE_TYPE_NONE = 0,
    //! Solid color style.
    BL_STYLE_TYPE_SOLID = 1,
    //! Pattern style.
    BL_STYLE_TYPE_PATTERN = 2,
    //! Gradient style.
    BL_STYLE_TYPE_GRADIENT = 3,

    //! Count of style types.
    BL_STYLE_TYPE_COUNT = 4
}

//! \ingroup blend2d_api_text
//!
//! Text encoding.
enum BLTextEncoding {
    //! UTF-8 encoding.
    BL_TEXT_ENCODING_UTF8 = 0,
    //! UTF-16 encoding (native endian).
    BL_TEXT_ENCODING_UTF16 = 1,
    //! UTF-32 encoding (native endian).
    BL_TEXT_ENCODING_UTF32 = 2,
    //! LATIN1 encoding (one byte per character).
    BL_TEXT_ENCODING_LATIN1 = 3,

    //! Platform native `wchar_t` (or Windows `WCHAR`) encoding, alias to
    //! either UTF-32, UTF-16, or UTF-8 depending on `sizeof(wchar_t)`.
    BL_TEXT_ENCODING_WCHAR
        = wchar_t.sizeof == 4 ? BL_TEXT_ENCODING_UTF32 :
          wchar_t.sizeof == 2 ? BL_TEXT_ENCODING_UTF16 : BL_TEXT_ENCODING_UTF8,

    //! Count of text supported text encodings.
    BL_TEXT_ENCODING_COUNT = 4
}

// ============================================================================
// [Public API - TraceError]
// ============================================================================

//! \addtogroup blend2d_api_globals
//! \{
//! \name Debugging Functionality
//! \{

//! Returns the `result` passed.
//!
//! Provided for debugging purposes. Putting a breakpoint inside `blTraceError()`
//! can help with tracing an origin of errors reported / returned by Blend2D as
//! each error goes through this function.
//!
//! It's a zero-cost solution that doesn't affect release builds in any way.
BLResult blTraceError(BLResult result);

//! \}
//! \}

// ============================================================================
// [BLRange]
// ============================================================================

//! \addtogroup blend2d_api_globals
//! \{

//! Provides start and end indexes. It's used to specify a range of an operation
//! related to indexed containers like `BLArray`, `BLPath`, `BLGradient`, etc...
struct BLRange {
    size_t start;
    size_t end;
}

//! \}

// ============================================================================
// [BLCreateForeignInfo]
// ============================================================================

//! \addtogroup blend2d_api_globals
//! \{

//! Structure passed to a constructor (initializer) that provides foreign data
//! that should be used to allocate its Impl (and data if it's a container).
struct BLCreateForeignInfo {
    void* data;
    size_t size;
    BLDestroyImplFunc destroyFunc;
    void* destroyData;
}

//! \}

// ============================================================================
// [BLArrayView]
// ============================================================================

//! \addtogroup blend2d_api_globals
//! \{

struct BLArrayView {
    const(void)* data;
    size_t size;
}

struct BLStringView {
    const(char)* data;
    size_t size;
}

struct BLRegionView {
    const(BLBoxI)* data;
    size_t size;
}

alias BLDataView = BLArrayView;

//! \}
